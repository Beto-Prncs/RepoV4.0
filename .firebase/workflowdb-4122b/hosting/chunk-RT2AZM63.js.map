{"version":3,"sources":["node_modules/@capacitor/browser/dist/esm/index.js","src/app/services/auth.service.ts"],"sourcesContent":["import { registerPlugin } from '@capacitor/core';\nconst Browser = registerPlugin('Browser', {\n  web: () => import('./web').then(m => new m.BrowserWeb())\n});\nexport * from './definitions';\nexport { Browser };\n","\nimport { Firestore, doc, getDoc, collection, query, where, getDocs, updateDoc } from '@angular/fire/firestore';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { Injectable, inject } from '@angular/core';\nimport {\n  Auth,\n  User,\n  browserSessionPersistence,\n  setPersistence,\n  signInWithEmailAndPassword,\n  signInWithPopup,\n  GoogleAuthProvider,\n  sendPasswordResetEmail,\n  confirmPasswordReset,\n  verifyPasswordResetCode\n} from '@angular/fire/auth';\nimport { Router } from '@angular/router';\nimport { Capacitor } from '@capacitor/core';\nimport { Browser } from '@capacitor/browser';\nimport { Usuario } from '../models/interfaces';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private auth: Auth = inject(Auth);\n  private firestore: Firestore = inject(Firestore);\n  private router: Router = inject(Router);\n  private currentUserSubject = new BehaviorSubject<Usuario | null>(null);\n  currentUser$ = this.currentUserSubject.asObservable();\n\n  constructor() {\n    this.initAuthListener();\n  }\n\n  private initAuthListener(): void {\n    this.auth.onAuthStateChanged(async (user) => {\n      if (user) {\n        const userData = await this.getUserData(user.uid);\n        this.currentUserSubject.next(userData);\n      } else {\n        this.currentUserSubject.next(null);\n      }\n    });\n  }\n\n  async getUserData(uid: string): Promise<Usuario | null> {\n    try {\n      const userDoc = await getDoc(doc(this.firestore, 'Usuario', uid));\n      if (userDoc.exists()) {\n        return {\n          ...userDoc.data() as Usuario,\n          IdUsuario: uid\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error obteniendo datos del usuario:', error);\n      return null;\n    }\n  }\n\n  // Método para obtener un usuario por su nombre de usuario\n  async getUserByUsername(username: string): Promise<Usuario | null> {\n    try {\n      const usersRef = collection(this.firestore, 'Usuario');\n      const q = query(usersRef, where('Username', '==', username));\n      const snapshot = await getDocs(q);\n      \n      if (!snapshot.empty) {\n        const userDoc = snapshot.docs[0];\n        return {\n          ...userDoc.data() as Usuario,\n          IdUsuario: userDoc.id\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error obteniendo usuario por username:', error);\n      return null;\n    }\n  }\n\n  // Método para obtener un usuario por su correo electrónico\n  async getUserByEmail(email: string): Promise<Usuario | null> {\n    try {\n      const usersRef = collection(this.firestore, 'Usuario');\n      const q = query(usersRef, where('Correo', '==', email));\n      const snapshot = await getDocs(q);\n      \n      if (!snapshot.empty) {\n        const userDoc = snapshot.docs[0];\n        return {\n          ...userDoc.data() as Usuario,\n          IdUsuario: userDoc.id\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error obteniendo usuario por email:', error);\n      return null;\n    }\n  }\n\n  async isAdmin(uid: string): Promise<boolean> {\n    const userData = await this.getUserData(uid);\n    return userData?.Rol === 'admin';\n  }\n\n  async isWorker(uid: string): Promise<boolean> {\n    const userData = await this.getUserData(uid);\n    return userData?.Rol === 'worker';\n  }\n\n  async getCurrentUser(): Promise<User | null> {\n    return new Promise((resolve) => {\n      const unsubscribe = this.auth.onAuthStateChanged(user => {\n        unsubscribe();\n        resolve(user);\n      });\n    });\n  }\n\n  async getUserToken(): Promise<string | null> {\n    try {\n      const user = this.auth.currentUser;\n      if (!user) {\n        return null;\n      }\n      return await user.getIdToken();\n    } catch (error) {\n      console.error('Error obteniendo token:', error);\n      return null;\n    }\n  }\n\n  async signOut(): Promise<void> {\n    try {\n      // Capturar la URL actual para preservar la ruta base\n      const baseUrl = window.location.origin;\n      // 1. Limpieza de estados locales\n      this.currentUserSubject.next(null);\n      localStorage.clear();\n      sessionStorage.clear();\n      // 2. Limpieza específica de Firebase\n      await this.auth.signOut();\n      // 3. Limpiar IndexedDB de manera más efectiva\n      const databases = ['firebaseLocalStorageDb', 'firebaseAuth', 'firebaseinstallations-database'];\n      databases.forEach(dbName => {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n        deleteRequest.onsuccess = () => console.log(`${dbName} eliminada correctamente`);\n        deleteRequest.onerror = () => console.warn(`Error al eliminar ${dbName}`);\n      });\n      // 4. Redirección con parámetros para forzar recarga y evitar caché\n      setTimeout(() => {\n        window.location.href = `${baseUrl}/login?forceRefresh=true&t=${Date.now()}`;\n      }, 300); // Pequeño retraso para asegurar que todo se limpie\n    } catch (error) {\n      console.error('Error al cerrar sesión:', error);\n      // Redirección en caso de error\n      window.location.href = '/login?error=true&t=' + Date.now();\n    }\n  }\n\n  private clearFirebaseTokens(): void {\n    // Eliminar tokens específicos de Firebase Auth\n    const keysToRemove = [];\n    // Buscar en localStorage\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && (\n        key.startsWith('firebase:') ||\n        key.includes('firebaseLocalStorageDb') ||\n        key.includes('firebaseAuth')\n      )) {\n        keysToRemove.push(key);\n      }\n    }\n    // Eliminar las claves identificadas\n    keysToRemove.forEach(key => localStorage.removeItem(key));\n  }\n\n  private clearAuthCookies(): void {\n    if (typeof document === 'undefined') return;\n    // Lista ampliada de cookies a limpiar\n    const cookiePrefixes = ['firebase', 'firebaseAuth', 'G_AUTH', 'G_AUTHUSER', 'goog', 'google'];\n    const cookies = document.cookie.split(';');\n    for (const cookie of cookies) {\n      const eqPos = cookie.indexOf('=');\n      const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();\n      // Verificar si la cookie está relacionada con la autenticación\n      const shouldClear = cookiePrefixes.some(prefix =>\n        name.toLowerCase().includes(prefix.toLowerCase()));\n      if (shouldClear) {\n        // Eliminar la cookie estableciendo una fecha de expiración pasada\n        // Intentar con diferentes paths y dominios para ser exhaustivos\n        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`;\n        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=${window.location.hostname}`;\n        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=.${window.location.hostname}`;\n      }\n    }\n  }\n\n  private async cleanGoogleAuth(): Promise<void> {\n    if (typeof window === 'undefined') return;\n    const google = (window as any).google;\n    if (!google?.accounts?.id) return;\n    try {\n      // Revocar todos los tokens de Google\n      google.accounts.id.disableAutoSelect();\n      // Intentar revocar el token actual\n      const currentUser = this.auth.currentUser;\n      if (currentUser?.email) {\n        return new Promise<void>((resolve) => {\n          google.accounts.id.revoke(currentUser.email, () => {\n            console.log('Google token revocado exitosamente');\n            resolve();\n          });\n        });\n      }\n    } catch (error) {\n      console.warn('Google auth cleanup failed (non-critical):', error);\n    }\n  }\n\n  private async clearIndexedDB(): Promise<void> {\n    try {\n      // Lista de nombres de bases de datos relacionadas con Firebase\n      const dbNames = ['firebaseLocalStorageDb', 'firebase-auth-container',\n      'firebase-installations-database'];\n      for (const dbName of dbNames) {\n        try {\n          // Intentar eliminar la base de datos\n          await window.indexedDB.deleteDatabase(dbName);\n        } catch (e) {\n          console.warn(`No se pudo eliminar la base de datos ${dbName}:`, e);\n        }\n      }\n    } catch (error) {\n      console.warn('Error al limpiar IndexedDB:', error);\n    }\n  }\n\n  private async cleanCapacitorAuth(): Promise<void> {\n    try {\n      // Cerrar cualquier ventana del navegador abierta (para flujo OAuth)\n      if (Capacitor.isPluginAvailable('Browser')) {\n        await Browser.close();\n      }\n    } catch (e) {\n      console.log('No se pudo cerrar el navegador en Capacitor:', e);\n    }\n  }\n\n  // En auth.service.ts\n  isAuthenticated(): boolean {\n    return this.auth.currentUser !== null;\n  }\n\n  // Método para establecer la persistencia\n  async setPersistenceSession(): Promise<void> {\n    return setPersistence(this.auth, browserSessionPersistence);\n  }\n\n  // Método para iniciar sesión con correo/contraseña\n  async signInWithEmailPassword(email: string, password: string) {\n    return signInWithEmailAndPassword(this.auth, email, password);\n  }\n\n  // Método para iniciar sesión con Google\n  async loginWithGoogle() {\n    await this.setPersistenceSession();\n    const provider = new GoogleAuthProvider();\n    provider.addScope('email');\n    return signInWithPopup(this.auth, provider);\n  }\n\n  // NUEVOS MÉTODOS PARA RECUPERACIÓN DE CONTRASEÑA\n  \n  /**\n   * Envía un correo de recuperación de contraseña\n   * @param email El correo electrónico del usuario\n   */\n  async sendPasswordResetEmail(email: string): Promise<void> {\n    // Primero verificamos si el correo existe en la base de datos\n    const user = await this.getUserByEmail(email);\n    if (!user) {\n      throw new Error('El correo electrónico no está registrado en el sistema');\n    }\n    \n    // Si existe, enviamos el correo de recuperación\n    return sendPasswordResetEmail(this.auth, email, {\n      url: `${window.location.origin}/login`,\n      handleCodeInApp: true\n    });\n  }\n\n  /**\n   * Verifica que el código de recuperación sea válido\n   * @param code El código de recuperación de la URL\n   */\n  async verifyPasswordResetCode(code: string): Promise<string> {\n    return verifyPasswordResetCode(this.auth, code);\n  }\n\n  /**\n   * Confirma el cambio de contraseña\n   * @param code El código de verificación\n   * @param newPassword La nueva contraseña\n   */\n  async confirmPasswordReset(code: string, newPassword: string): Promise<void> {\n    await confirmPasswordReset(this.auth, code, newPassword);\n    \n    // También actualizamos la contraseña en Firestore para mantener la coherencia\n    try {\n      // 1. Obtenemos el email del usuario usando el código de reset\n      const email = await this.verifyPasswordResetCode(code);\n      \n      // 2. Buscamos el usuario por email\n      const user = await this.getUserByEmail(email);\n      if (user && user.IdUsuario) {\n        // 3. Actualizamos la contraseña en Firestore\n        const userRef = doc(this.firestore, 'Usuario', user.IdUsuario);\n        await updateDoc(userRef, { Password: newPassword });\n      }\n    } catch (error) {\n      console.error('Error actualizando contraseña en Firestore:', error);\n      // No interrumpimos el flujo si este paso falla\n    }\n  }\n\n  // Métodos para filtrado de usuarios según el nivel del administrador\n  async getFilteredUsers(): Promise<Usuario[]> {\n    try {\n      const currentUser = await this.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n      \n      const userData = await this.getUserData(currentUser.uid);\n      if (!userData) {\n        throw new Error('No se encontraron datos del usuario');\n      }\n      \n      // Si es admin nivel 3, devolver solo sus usuarios creados\n      if (userData.Rol === 'admin' && userData.NivelAdmin === '3') {\n        return this.getUsersByCreator(currentUser.uid);\n      }\n      \n      // Para otros casos, devolver todos los usuarios\n      return this.getAllUsers();\n    } catch (error) {\n      console.error('Error al filtrar usuarios:', error);\n      return [];\n    }\n  }\n\n  async getUsersCreatedBy(adminId: string): Promise<Usuario[]> {\n    try {\n      const usersQuery = query(\n        collection(this.firestore, 'Usuario'),\n        where('createdBy', '==', adminId)\n      );\n      const snapshot = await getDocs(usersQuery);\n      return snapshot.docs.map(doc => ({\n        ...doc.data() as Usuario,\n        IdUsuario: doc.id\n      }));\n    } catch (error) {\n      console.error('Error obteniendo usuarios creados por el admin:', error);\n      return [];\n    }\n  }\n\n  async getWorkersCreatedBy(adminId: string): Promise<Usuario[]> {\n    try {\n      const workersQuery = query(\n        collection(this.firestore, 'Usuario'),\n        where('createdBy', '==', adminId),\n        where('Rol', '==', 'worker')\n      );\n      const snapshot = await getDocs(workersQuery);\n      return snapshot.docs.map(doc => ({\n        ...doc.data() as Usuario,\n        IdUsuario: doc.id\n      }));\n    } catch (error) {\n      console.error('Error obteniendo trabajadores creados por el admin:', error);\n      return [];\n    }\n  }\n\n  async getUsersByCreator(creatorId: string): Promise<Usuario[]> {\n    try {\n      const usersRef = collection(this.firestore, 'Usuario');\n      const q = query(usersRef, where('createdBy', '==', creatorId));\n      const querySnapshot = await getDocs(q);\n      const users: Usuario[] = [];\n      querySnapshot.forEach((doc) => {\n        users.push({\n          IdUsuario: doc.id,\n          ...doc.data() as Omit<Usuario, 'IdUsuario'>\n        });\n      });\n      return users;\n    } catch (error) {\n      console.error('Error obteniendo usuarios por creador:', error);\n      return [];\n    }\n  }\n\n  async getAllUsers(): Promise<Usuario[]> {\n    try {\n      const usersRef = collection(this.firestore, 'Usuario');\n      const querySnapshot = await getDocs(usersRef);\n      const users: Usuario[] = [];\n      querySnapshot.forEach((doc) => {\n        users.push({\n          IdUsuario: doc.id,\n          ...doc.data() as Omit<Usuario, 'IdUsuario'>\n        });\n      });\n      return users;\n    } catch (error) {\n      console.error('Error obteniendo todos los usuarios:', error);\n      return [];\n    }\n  }\n}"],"mappings":"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","names":["Browser","registerPlugin","m","AuthService","auth","inject","Auth","firestore","Firestore","router","Router","currentUserSubject","BehaviorSubject","currentUser$","asObservable","constructor","initAuthListener","onAuthStateChanged","user","__async","userData","getUserData","uid","next","userDoc","getDoc","doc","exists","__spreadProps","__spreadValues","data","IdUsuario","error","console","getUserByUsername","username","usersRef","collection","q","query","where","snapshot","getDocs","empty","docs","id","getUserByEmail","email","isAdmin","Rol","isWorker","getCurrentUser","Promise","resolve","unsubscribe","getUserToken","currentUser","getIdToken","signOut","baseUrl","window","location","origin","localStorage","clear","sessionStorage","forEach","dbName","deleteRequest","indexedDB","deleteDatabase","onsuccess","log","onerror","warn","setTimeout","href","Date","now","clearFirebaseTokens","keysToRemove","i","length","key","startsWith","includes","push","removeItem","clearAuthCookies","document","cookiePrefixes","cookies","cookie","split","eqPos","indexOf","name","substr","trim","some","prefix","toLowerCase","hostname","cleanGoogleAuth","google","accounts","disableAutoSelect","revoke","clearIndexedDB","dbNames","e","cleanCapacitorAuth","Capacitor","isPluginAvailable","Browser","close","isAuthenticated","setPersistenceSession","setPersistence","browserSessionPersistence","signInWithEmailPassword","password","signInWithEmailAndPassword","loginWithGoogle","provider","GoogleAuthProvider","addScope","signInWithPopup","sendPasswordResetEmail","Error","url","handleCodeInApp","verifyPasswordResetCode","code","confirmPasswordReset","newPassword","userRef","updateDoc","Password","getFilteredUsers","NivelAdmin","getUsersByCreator","getAllUsers","getUsersCreatedBy","adminId","usersQuery","map","getWorkersCreatedBy","workersQuery","creatorId","querySnapshot","users","factory","ɵfac","providedIn"],"x_google_ignoreList":[0]}