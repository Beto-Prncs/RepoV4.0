{
  "version": 3,
  "sources": ["src/app/services/task.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\nimport {\n  Firestore,\n  collection,\n  addDoc,\n  deleteDoc,\n  doc,\n  query,\n  where,\n  collectionData,\n  updateDoc,\n  getDocs,\n  getDoc\n} from '@angular/fire/firestore';\nimport { Observable, from, map, of } from 'rxjs';\nimport { Reporte } from '../models/interfaces';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TaskService {\n  private firestore: Firestore = inject(Firestore);\n  private authService: AuthService = inject(AuthService);\n\n  async assignReporte(reporte: Omit<Reporte, 'IdReporte'>): Promise<string> {\n    try {\n      // 1. Obtener el usuario actual y verificar que sea admin\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n\n      // 2. Obtener los datos del usuario actual desde Firestore\n      const adminDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      if (!adminDoc.exists()) {\n        throw new Error('Usuario administrador no encontrado');\n      }\n\n      const adminData = adminDoc.data();\n      if (adminData['Rol'] !== 'admin') {\n        throw new Error('No tiene permisos para crear reportes');\n      }\n\n      // 3. Buscar el usuario trabajador por su Username\n      const workersRef = collection(this.firestore, 'Usuario');\n      const workerQuery = query(workersRef, \n        where('Username', '==', reporte.IdUsuario),\n        where('Rol', '==', 'worker')\n      );\n      \n      const workerSnapshot = await getDocs(workerQuery);\n      \n      if (workerSnapshot.empty) {\n        throw new Error('Usuario trabajador no encontrado');\n      }\n\n      const workerDoc = workerSnapshot.docs[0];\n      const workerId = workerDoc.id;\n\n      // 4. Crear el reporte con los datos validados y el ID correcto del trabajador\n      const reportesRef = collection(this.firestore, 'Reportes');\n      const reporteData = {\n        fecha: new Date(),\n        estado: 'Pendiente',\n        IdEmpresa: reporte.IdEmpresa,\n        IdUsuario: workerId, // Usar el ID real del trabajador\n        Tipo_Trabajo: reporte.Tipo_Trabajo,\n        jobDescription: reporte.jobDescription,\n        location: reporte.location,\n        priority: reporte.priority,\n        departamento: reporte.departamento,\n        fechaActualizacion: new Date()\n      };\n\n      // 5. Guardar el reporte\n      const docRef = await addDoc(reportesRef, reporteData);\n\n      // 6. Actualizar el ID del reporte\n      await updateDoc(doc(this.firestore, 'Reportes', docRef.id), {\n        IdReporte: docRef.id\n      });\n\n      console.log('Reporte creado exitosamente:', docRef.id);\n      return docRef.id;\n\n    } catch (error) {\n      console.error('Error al asignar reporte:', error);\n      throw error;\n    }\n  }\n\n  getReportes(): Observable<Reporte[]> {\n    console.log('Obteniendo todos los reportes');\n    const reportesRef = collection(this.firestore, 'Reportes');\n    return collectionData(reportesRef, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes recuperados:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n  getPendingReportesByWorker(userId: string): Observable<Reporte[]> {\n    if (!userId) {\n      console.error('UserId es requerido para obtener reportes pendientes');\n      return of([]);\n    }\n\n    console.log('Buscando reportes pendientes para userId:', userId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('IdUsuario', '==', userId),\n      where('estado', '==', 'Pendiente')\n    );\n\n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes pendientes encontrados:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n  getCompletedReportesByWorker(userId: string): Observable<Reporte[]> {\n    if (!userId) {\n      console.error('UserId es requerido para obtener reportes completados');\n      return of([]);\n    }\n\n    console.log('Buscando reportes completados para userId:', userId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('IdUsuario', '==', userId),\n      where('estado', '==', 'Completado')\n    );\n\n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes completados encontrados:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n  async updateReporteStatus(\n    reporteId: string,\n    status: string,\n    descripcion?: string\n  ): Promise<void> {\n    try {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n\n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      const reporteDoc = await getDoc(reporteRef);\n\n      if (!reporteDoc.exists()) {\n        throw new Error('El reporte no existe');\n      }\n\n      const reporteData = reporteDoc.data();\n\n      const userDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      if (!userDoc.exists()) {\n        throw new Error('Usuario no encontrado');\n      }\n\n      const userData = userDoc.data();\n      const isAdmin = userData['Rol'] === 'admin';\n      const isAssignedWorker = reporteData['IdUsuario'] === currentUser.uid;\n\n      if (!isAdmin && !isAssignedWorker) {\n        throw new Error('No tiene permisos para actualizar este reporte');\n      }\n\n      const updateData: any = {\n        estado: status,\n        fechaActualizacion: new Date()\n      };\n\n      if (status === 'Completado') {\n        updateData.fechaCompletado = new Date();\n        if (descripcion) {\n          updateData.descripcionCompletado = descripcion;\n        }\n      }\n\n      await updateDoc(reporteRef, updateData);\n      console.log('Estado del reporte actualizado exitosamente');\n    } catch (error) {\n      console.error('Error al actualizar estado del reporte:', error);\n      throw error;\n    }\n  }\n\n  async deleteReporte(reporteId: string): Promise<void> {\n    try {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n\n      // Verificar si el usuario es admin\n      const userDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      if (!userDoc.exists()) {\n        throw new Error('Usuario no encontrado');\n      }\n\n      const userData = userDoc.data();\n      if (userData['Rol'] !== 'admin') {\n        throw new Error('Solo los administradores pueden eliminar reportes');\n      }\n\n      // Verificar que el reporte existe\n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      const reporteDoc = await getDoc(reporteRef);\n      if (!reporteDoc.exists()) {\n        throw new Error('El reporte no existe');\n      }\n\n      console.log('Eliminando reporte:', reporteId);\n      await deleteDoc(reporteRef);\n      console.log('Reporte eliminado exitosamente');\n    } catch (error) {\n      console.error('Error al eliminar reporte:', error);\n      throw error;\n    }\n  }\n\n  // Método auxiliar para procesar las fechas de los reportes\n  private processReportes(reportes: any[]): Reporte[] {\n    return reportes.map(reporte => ({\n      ...reporte,\n      fecha: reporte.fecha?.toDate?.() || new Date(reporte.fecha),\n      fechaCompletado: reporte.fechaCompletado?.toDate?.() ||\n                      (reporte.fechaCompletado ? new Date(reporte.fechaCompletado) : undefined),\n      fechaActualizacion: reporte.fechaActualizacion?.toDate?.() || \n                         (reporte.fechaActualizacion ? new Date(reporte.fechaActualizacion) : new Date())\n    }));\n  }\n\n  // Método para obtener reportes por departamento\n  getReportesByDepartamento(departamento: string): Observable<Reporte[]> {\n    if (!departamento) {\n      console.error('Departamento es requerido para obtener reportes');\n      return of([]);\n    }\n\n    console.log('Buscando reportes para departamento:', departamento);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('departamento', '==', departamento)\n    );\n\n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados para departamento:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n  // Método para obtener reportes por empresa\n  getReportesByEmpresa(empresaId: string): Observable<Reporte[]> {\n    if (!empresaId) {\n      console.error('ID de empresa es requerido para obtener reportes');\n      return of([]);\n    }\n\n    console.log('Buscando reportes para empresa:', empresaId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('IdEmpresa', '==', empresaId)\n    );\n\n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados para empresa:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n  // Método para obtener reportes por prioridad\n  getReportesByPriority(priority: string): Observable<Reporte[]> {\n    if (!priority) {\n      console.error('Prioridad es requerida para obtener reportes');\n      return of([]);\n    }\n\n    console.log('Buscando reportes por prioridad:', priority);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('priority', '==', priority)\n    );\n\n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados por prioridad:', reportes);\n        return this.processReportes(reportes);\n      })\n    );\n  }\n\n\n\n// Método para obtener reportes filtrados por el administrador actual\nasync getFilteredReportes(): Promise<Observable<Reporte[]>> {\n  try {\n    const currentUser = await this.authService.getCurrentUser();\n    if (!currentUser) {\n      console.error('No hay usuario autenticado');\n      return of([]);\n    }\n    \n    // Obtener datos del usuario actual\n    const userData = await this.authService.getUserData(currentUser.uid);\n    if (!userData) {\n      console.error('Datos de usuario no encontrados');\n      return of([]);\n    }\n    \n    // Si es admin nivel 3, filtrar reportes solo de usuarios creados por él\n    if (userData.Rol === 'admin' && userData.NivelAdmin === '3') {\n      return this.getReportesByCreator(currentUser.uid);\n    }\n    \n    // Para otros casos, devolver todos los reportes\n    return this.getReportes();\n  } catch (error) {\n    console.error('Error al filtrar reportes:', error);\n    return of([]);\n  }\n}\n\n// Método para obtener reportes de usuarios creados por un administrador específico\n  getReportesByCreator(creatorId: string): Observable<Reporte[]> {\n    return new Observable<Reporte[]>(observer => {\n      // Primero obtenemos los usuarios creados por este administrador\n      this.authService.getUsersByCreator(creatorId).then(users => {\n        // Extraer solo los IDs de los usuarios\n        const userIds = users.map(user => user.IdUsuario);\n        \n        if (userIds.length === 0) {\n          observer.next([]);\n          observer.complete();\n          return;\n        }\n        \n        // Obtener reportes para estos usuarios\n        const reportesRef = collection(this.firestore, 'Reportes');\n        \n        // Firebase no permite consultas 'IN' con más de 10 elementos\n        // Dividimos en grupos de 10 si es necesario\n        const userIdChunks = this.chunkArray(userIds, 10);\n        const reportePromises: Promise<Reporte[]>[] = [];\n        \n        userIdChunks.forEach(chunk => {\n          const q = query(reportesRef, where('IdUsuario', 'in', chunk));\n          const promise = getDocs(q).then(snapshot => {\n            const reportes: any[] = [];\n            snapshot.forEach(doc => {\n              reportes.push({\n                IdReporte: doc.id,\n                ...doc.data()\n              });\n            });\n            return this.processReportes(reportes);\n          });\n          reportePromises.push(promise);\n        });\n        \n        Promise.all(reportePromises).then(reportesArrays => {\n          // Combinar todos los arrays de reportes\n          const allReportes = reportesArrays.flat();\n          observer.next(allReportes);\n          observer.complete();\n        }).catch(error => {\n          console.error('Error obteniendo reportes:', error);\n          observer.error(error);\n        });\n      }).catch(error => {\n        console.error('Error obteniendo usuarios:', error);\n        observer.error(error);\n      });\n    });\n  }\n\n  // Método auxiliar para dividir arrays en grupos de un tamaño específico\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n}"],
  "mappings": "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",
  "names": ["TaskService", "firestore", "inject", "Firestore", "authService", "AuthService", "assignReporte", "reporte", "__async", "currentUser", "getCurrentUser", "Error", "adminDoc", "getDoc", "doc", "uid", "exists", "data", "workersRef", "collection", "workerQuery", "query", "where", "IdUsuario", "workerSnapshot", "getDocs", "empty", "workerId", "docs", "id", "reportesRef", "reporteData", "fecha", "Date", "estado", "IdEmpresa", "Tipo_Trabajo", "jobDescription", "location", "priority", "departamento", "fechaActualizacion", "docRef", "addDoc", "updateDoc", "IdReporte", "console", "log", "error", "getReportes", "collectionData", "idField", "pipe", "map", "reportes", "processReportes", "getPendingReportesByWorker", "userId", "of", "reportesQuery", "getCompletedReportesByWorker", "updateReporteStatus", "reporteId", "status", "descripcion", "reporteRef", "reporteDoc", "userDoc", "isAdmin", "isAssignedWorker", "updateData", "fechaCompletado", "descripcionCompletado", "deleteReporte", "deleteDoc", "__spreadProps", "__spreadValues", "toDate", "undefined", "getReportesByDepartamento", "getReportesByEmpresa", "empresaId", "getReportesByPriority", "getFilteredReportes", "userData", "getUserData", "Rol", "NivelAdmin", "getReportesByCreator", "creatorId", "Observable", "observer", "getUsersByCreator", "then", "users", "userIds", "user", "length", "next", "complete", "userIdChunks", "chunkArray", "reportePromises", "forEach", "chunk", "q", "promise", "snapshot", "push", "Promise", "all", "reportesArrays", "allReportes", "flat", "catch", "array", "chunkSize", "chunks", "i", "slice", "factory", "\u0275fac", "providedIn"]
}
