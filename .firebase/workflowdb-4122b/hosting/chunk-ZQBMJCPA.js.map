{
  "version": 3,
  "sources": ["src/app/environments/environments.ts", "src/app/services/cloudinary-image.service.ts"],
  "sourcesContent": ["\nexport const environment =\n{\n    firebaseConfig : \n    {\n      apiKey: \"AIzaSyB02aFRJQaUZV4PH-1UilL0G1qR011UMOo\",\n      authDomain: \"workflowdb-4122b.firebaseapp.com\",\n      projectId: \"workflowdb-4122b\",\n      storageBucket: \"workflowdb-4122b.firebasestorage.app\",\n      messagingSenderId: \"1053802838055\",\n      appId: \"1:1053802838055:web:17ffaf05c2fe045c77b602\",\n      persistence: 'session'\n    },\n    cloudinary: \n    {\n      cloudName: 'dqv73l7uc',  \n      apiKey: '747314796397951',  \n      uploadPreset: 'profile_images'\n    }\n}", "import { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, from, throwError } from 'rxjs';\nimport { map, catchError, switchMap } from 'rxjs/operators';\nimport { environment } from '../environments/environments';\nimport { Firestore, doc, updateDoc } from '@angular/fire/firestore';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CloudinaryImageService {\n  private readonly cloudName: string = environment.cloudinary.cloudName;\n  private readonly uploadPreset: string = environment.cloudinary.uploadPreset;\n  private readonly uploadUrl: string = `https://api.cloudinary.com/v1_1/${this.cloudName}/image/upload`;\n\n  private http = inject(HttpClient);\n  private firestore = inject(Firestore);\n\n  /**\n   * Sube una imagen a Cloudinary y actualiza el perfil del usuario\n   */\n  uploadProfileImage(file: File, userId: string, collectionName: string = 'Usuario'): Observable<string> {\n    // Validaciones básicas\n    if (!file || !file.type.includes('image')) {\n      return throwError(() => new Error('El archivo debe ser una imagen'));\n    }\n    if (!userId) {\n      return throwError(() => new Error('ID de usuario no disponible'));\n    }\n\n    // Preparar FormData para la subida a Cloudinary\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('upload_preset', this.uploadPreset);\n    formData.append('public_id', `user_${userId}_${Date.now()}`); // ID único\n    \n    // Subir a Cloudinary\n    return this.http.post<any>(this.uploadUrl, formData).pipe(\n      switchMap(response => {\n        const imageUrl = response.secure_url;\n        \n        // Actualizar Firestore con la nueva URL\n        const userRef = doc(this.firestore, collectionName, userId);\n        return from(updateDoc(userRef, {\n          Foto_Perfil: imageUrl\n        })).pipe(\n          map(() => imageUrl) // Devolver la URL de la imagen\n        );\n      }),\n      catchError(error => {\n        console.error('Error al subir imagen:', error);\n        return throwError(() => new Error('Error al subir imagen: ' + (error.message || 'Intente nuevamente')));\n      })\n    );\n  }\n\n  /**\n   * Optimiza y comprime una imagen antes de subirla\n   */\n  async optimizeImage(file: File, maxWidth: number = 500): Promise<File> {\n    return new Promise((resolve, reject) => {\n      try {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          const img = new Image();\n          img.onload = () => {\n            // Determinar nuevas dimensiones manteniendo el aspect ratio\n            let width = img.width;\n            let height = img.height;\n            \n            if (width > maxWidth) {\n              height = Math.round((height * maxWidth) / width);\n              width = maxWidth;\n            }\n            \n            // Crear canvas para redimensionar\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            \n            // Dibujar imagen redimensionada\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n              reject(new Error('No se pudo obtener el contexto 2D del canvas'));\n              return;\n            }\n            \n            ctx.drawImage(img, 0, 0, width, height);\n            \n            // Convertir a Blob\n            canvas.toBlob((blob) => {\n              if (!blob) {\n                reject(new Error('Error al generar blob'));\n                return;\n              }\n              \n              // Crear nuevo archivo con el mismo nombre pero comprimido\n              const optimizedFile = new File([blob], file.name, {\n                type: 'image/jpeg',\n                lastModified: Date.now()\n              });\n              \n              resolve(optimizedFile);\n            }, 'image/jpeg', 0.85); // Calidad 85%\n          };\n          \n          img.onerror = () => {\n            reject(new Error('Error al cargar la imagen para optimización'));\n          };\n          \n          img.src = event.target?.result as string;\n        };\n        \n        reader.onerror = () => {\n          reject(new Error('Error al leer el archivo para optimización'));\n        };\n        \n        reader.readAsDataURL(file);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Actualiza la imagen de perfil, primero optimizándola\n   */\n  async updateProfileImage(file: File, userId: string): Promise<Observable<string>> {\n    try {\n      // Optimizar la imagen antes de subirla\n      const optimizedFile = await this.optimizeImage(file);\n      // Subir la imagen optimizada\n      return this.uploadProfileImage(optimizedFile, userId);\n    } catch (error) {\n      return throwError(() => error);\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["environment", "firebaseConfig", "apiKey", "authDomain", "projectId", "storageBucket", "messagingSenderId", "appId", "persistence", "cloudinary", "cloudName", "uploadPreset", "CloudinaryImageService", "cloudName", "environment", "cloudinary", "uploadPreset", "uploadUrl", "http", "inject", "HttpClient", "firestore", "Firestore", "uploadProfileImage", "file", "userId", "collectionName", "type", "includes", "throwError", "Error", "formData", "FormData", "append", "Date", "now", "post", "pipe", "switchMap", "response", "imageUrl", "secure_url", "userRef", "doc", "from", "updateDoc", "Foto_Perfil", "map", "catchError", "error", "console", "message", "optimizeImage", "maxWidth", "__async", "Promise", "resolve", "reject", "reader", "FileReader", "onload", "event", "img", "Image", "width", "height", "Math", "round", "canvas", "document", "createElement", "ctx", "getContext", "drawImage", "toBlob", "blob", "optimizedFile", "File", "name", "lastModified", "onerror", "src", "target", "result", "readAsDataURL", "updateProfileImage", "factory", "\u0275fac", "providedIn"]
}
