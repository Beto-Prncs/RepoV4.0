{
  "version": 3,
  "sources": ["src/app/environments/environments.ts", "src/app/services/cloudinary-image.service.ts"],
  "sourcesContent": ["\nexport const environment =\n{\n  production: false,\n  appUrl:'workflowdb-4122b.web.app',\n    firebaseConfig : \n    {\n      apiKey: \"AIzaSyB02aFRJQaUZV4PH-1UilL0G1qR011UMOo\",\n      authDomain: \"workflowdb-4122b.firebaseapp.com\",\n      projectId: \"workflowdb-4122b\",\n      storageBucket: \"workflowdb-4122b.firebasestorage.app\",\n      messagingSenderId: \"1053802838055\",\n      appId: \"1:1053802838055:web:17ffaf05c2fe045c77b602\",\n      persistence: 'session'\n    },\n    cloudinary: \n    {\n      cloudName: 'dqv73l7uc',  \n      apiKey: '747314796397951',  \n      uploadPreset: 'profile_images'\n    }\n}", "import { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, from, throwError, of } from 'rxjs';\nimport { map, catchError, switchMap } from 'rxjs/operators';\nimport { environment } from '../environments/environments';\nimport { Firestore, doc, updateDoc, arrayUnion } from '@angular/fire/firestore';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CloudinaryImageService {\n  private readonly cloudName: string = environment.cloudinary.cloudName;\n  private readonly uploadPreset: string = environment.cloudinary.uploadPreset;\n  private readonly uploadUrl: string = `https://api.cloudinary.com/v1_1/${this.cloudName}/image/upload`;\n  \n  // Para guardar URLs de Cloudinary en memoria caché\n  private imageCache = new Map<string, string>();\n\n  private http = inject(HttpClient);\n  private firestore = inject(Firestore);\n\n  /**\n   * Sube una imagen a Cloudinary sin actualizar ningún documento en Firestore\n   * @param file Archivo a subir\n   * @param idPrefix Prefijo para el ID público\n   * @param folder Carpeta en Cloudinary\n   * @returns Observable con la URL segura de Cloudinary\n   */\n  uploadImage(file: File, idPrefix: string, folder: string = 'reportes'): Observable<string> {\n    // Validaciones básicas\n    if (!file || !file.type.includes('image')) {\n      return throwError(() => new Error('El archivo debe ser una imagen'));\n    }\n\n    // Generar un ID único\n    const uniqueId = `${idPrefix}_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n    \n    // Preparar FormData para la subida a Cloudinary\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('upload_preset', this.uploadPreset);\n    formData.append('public_id', uniqueId);\n    formData.append('folder', folder);\n    \n    // Añadir etiquetas para mejor organización\n    formData.append('tags', folder + ',' + idPrefix);\n    \n    // Opciones para mejorar la entrega de imágenes\n    formData.append('quality', 'auto');\n    formData.append('fetch_format', 'auto');\n    \n    // Subir a Cloudinary\n    return this.http.post<any>(this.uploadUrl, formData).pipe(\n      map(response => {\n        const imageUrl = response.secure_url;\n        \n        // Guardar en caché para futuras referencias\n        this.cacheImageUrl(uniqueId, imageUrl);\n        \n        return imageUrl;\n      }),\n      catchError(error => {\n        console.error('Error al subir imagen a Cloudinary:', error);\n        return throwError(() => new Error('Error al subir imagen: ' + (error.message || 'Intente nuevamente')));\n      })\n    );\n  }\n\n  /**\n   * Sube una imagen a Cloudinary y actualiza el documento en Firestore\n   * @param file Archivo a subir\n   * @param docId ID del documento\n   * @param collectionName Nombre de la colección\n   * @param fieldName Campo a actualizar (por defecto 'Foto_Perfil')\n   * @returns Observable con la URL de la imagen\n   */\n  uploadProfileImage(file: File, docId: string, collectionName: string = 'Usuario', fieldName: string = 'Foto_Perfil'): Observable<string> {\n    // Validaciones básicas\n    if (!file || !file.type.includes('image')) {\n      return throwError(() => new Error('El archivo debe ser una imagen'));\n    }\n    if (!docId) {\n      return throwError(() => new Error('ID de documento no disponible'));\n    }\n\n    // Preparar FormData para la subida a Cloudinary\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('upload_preset', this.uploadPreset);\n    \n    // Organización de imágenes por carpetas y etiquetas\n    const uniqueId = `${collectionName}_${docId}_${Date.now()}`;\n    formData.append('public_id', uniqueId);\n    formData.append('folder', collectionName);\n    formData.append('tags', collectionName + ',' + docId);\n    \n    // Configuración de calidad\n    formData.append('quality', 'auto');\n    formData.append('fetch_format', 'auto');\n    \n    // Subir a Cloudinary\n    return this.http.post<any>(this.uploadUrl, formData).pipe(\n      switchMap(response => {\n        const imageUrl = response.secure_url;\n        \n        // Guardar en caché\n        this.cacheImageUrl(uniqueId, imageUrl);\n        \n        // Para reportes, podemos querer añadir la URL a un array en lugar de reemplazar un campo\n        if (collectionName === 'Reportes' && fieldName === 'evidenceImages') {\n          // Actualizar un array de imágenes\n          const docRef = doc(this.firestore, collectionName, docId);\n          return from(updateDoc(docRef, {\n            [fieldName]: arrayUnion(imageUrl) // Añadir al array sin duplicados\n          })).pipe(\n            map(() => imageUrl)\n          );\n        } else {\n          // Actualizar Firestore con la nueva URL\n          const docRef = doc(this.firestore, collectionName, docId);\n          return from(updateDoc(docRef, {\n            [fieldName]: imageUrl // Actualizar el campo especificado\n          })).pipe(\n            map(() => imageUrl)\n          );\n        }\n      }),\n      catchError(error => {\n        console.error('Error al subir imagen o actualizar documento:', error);\n        return throwError(() => new Error('Error al procesar imagen: ' + (error.message || 'Intente nuevamente')));\n      })\n    );\n  }\n\n  /**\n   * Sube múltiples imágenes a Cloudinary\n   * @param files Array de archivos a subir\n   * @param docId ID del documento\n   * @param collectionName Nombre de la colección\n   * @returns Observable con array de URLs\n   */\n  uploadMultipleImages(files: File[], docId: string, collectionName: string = 'Reportes'): Observable<string[]> {\n    if (!files || files.length === 0) {\n      return of([]);\n    }\n\n    // Filtrar solo imágenes\n    const imageFiles = files.filter(file => file.type.includes('image'));\n    \n    if (imageFiles.length === 0) {\n      return of([]);\n    }\n\n    // Crear un array de observables, uno por cada imagen\n    const uploadObservables = imageFiles.map(file => \n      from(this.optimizeImage(file)).pipe(\n        switchMap(optimizedFile => this.uploadImage(optimizedFile, `${collectionName}_${docId}`, collectionName))\n      )\n    );\n\n    // Combinar todos los observables en uno solo que emita array de URLs\n    return from(Promise.all(uploadObservables.map(obs => \n      obs.toPromise().catch(error => {\n        console.error('Error en subida individual:', error);\n        return null; // Devolver null para los que fallan\n      })\n    ))).pipe(\n      map(results => results.filter(url => url !== null) as string[])\n    );\n  }\n\n  /**\n   * Optimiza y comprime una imagen antes de subirla\n   * @param file Archivo de imagen a optimizar\n   * @param maxWidth Ancho máximo (por defecto 1200px)\n   * @returns Promise con el archivo optimizado\n   */\n  async optimizeImage(file: File, maxWidth: number = 1200): Promise<File> {\n    return new Promise((resolve, reject) => {\n      try {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          const img = new Image();\n          img.onload = () => {\n            // Determinar nuevas dimensiones manteniendo el aspect ratio\n            let width = img.width;\n            let height = img.height;\n            \n            if (width > maxWidth) {\n              height = Math.round((height * maxWidth) / width);\n              width = maxWidth;\n            }\n            \n            // Crear canvas para redimensionar\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            \n            // Dibujar imagen redimensionada\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n              reject(new Error('No se pudo obtener el contexto 2D del canvas'));\n              return;\n            }\n            \n            ctx.drawImage(img, 0, 0, width, height);\n            \n            // Convertir a Blob\n            canvas.toBlob((blob) => {\n              if (!blob) {\n                reject(new Error('Error al generar blob'));\n                return;\n              }\n              \n              // Crear nuevo archivo con el mismo nombre pero comprimido\n              const optimizedFile = new File([blob], file.name, {\n                type: 'image/jpeg',\n                lastModified: Date.now()\n              });\n              \n              resolve(optimizedFile);\n            }, 'image/jpeg', 0.85); // Calidad 85%\n          };\n          \n          img.onerror = () => {\n            reject(new Error('Error al cargar la imagen para optimización'));\n          };\n          \n          img.src = event.target?.result as string;\n        };\n        \n        reader.onerror = () => {\n          reject(new Error('Error al leer el archivo para optimización'));\n        };\n        \n        reader.readAsDataURL(file);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Actualiza la imagen de perfil, primero optimizándola\n   * @param file Archivo de imagen\n   * @param userId ID del usuario\n   * @returns Observable con la URL de la imagen\n   */\n  async updateProfileImage(file: File, userId: string): Promise<Observable<string>> {\n    try {\n      // Optimizar la imagen antes de subirla\n      const optimizedFile = await this.optimizeImage(file);\n      // Subir la imagen optimizada\n      return this.uploadProfileImage(optimizedFile, userId);\n    } catch (error) {\n      return throwError(() => error);\n    }\n  }\n\n  /**\n   * Almacena la URL de una imagen en la caché local\n   * @param id Identificador único de la imagen\n   * @param url URL de Cloudinary\n   */\n  private cacheImageUrl(id: string, url: string): void {\n    this.imageCache.set(id, url);\n  }\n\n  /**\n   * Obtiene una URL de Cloudinary de la caché\n   * @param id Identificador único de la imagen\n   * @returns URL de Cloudinary o null si no existe\n   */\n  getCachedImageUrl(id: string): string | null {\n    return this.imageCache.get(id) || null;\n  }\n\n  /**\n   * Elimina una URL de la caché\n   * @param id Identificador único de la imagen\n   */\n  removeCachedImage(id: string): void {\n    this.imageCache.delete(id);\n  }\n\n  /**\n   * Extrae el public_id de una URL de Cloudinary\n   * @param cloudinaryUrl URL completa de Cloudinary\n   * @returns public_id de la imagen\n   */\n  extractPublicId(cloudinaryUrl: string): string | null {\n    // Ejemplo: https://res.cloudinary.com/CLOUD_NAME/image/upload/v1234567890/folder/image_id.jpg\n    try {\n      const urlParts = cloudinaryUrl.split('/');\n      // Buscar la posición de 'upload' en la URL\n      const uploadIndex = urlParts.findIndex(part => part === 'upload');\n      \n      if (uploadIndex === -1 || uploadIndex + 2 >= urlParts.length) {\n        return null;\n      }\n      \n      // Obtener todo después de 'upload/v12345/'\n      const parts = urlParts.slice(uploadIndex + 2);\n      \n      // Eliminar la extensión del archivo\n      let publicId = parts.join('/');\n      const extensionIndex = publicId.lastIndexOf('.');\n      \n      if (extensionIndex !== -1) {\n        publicId = publicId.substring(0, extensionIndex);\n      }\n      \n      return publicId;\n    } catch (error) {\n      console.error('Error al extraer public_id:', error);\n      return null;\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["environment", "production", "appUrl", "firebaseConfig", "apiKey", "authDomain", "projectId", "storageBucket", "messagingSenderId", "appId", "persistence", "cloudinary", "cloudName", "uploadPreset", "CloudinaryImageService", "cloudName", "environment", "cloudinary", "uploadPreset", "uploadUrl", "imageCache", "Map", "http", "inject", "HttpClient", "firestore", "Firestore", "uploadImage", "file", "idPrefix", "folder", "type", "includes", "throwError", "Error", "uniqueId", "Date", "now", "Math", "random", "toString", "substring", "formData", "FormData", "append", "post", "pipe", "map", "response", "imageUrl", "secure_url", "cacheImageUrl", "catchError", "error", "console", "message", "uploadProfileImage", "docId", "collectionName", "fieldName", "switchMap", "docRef", "doc", "from", "updateDoc", "arrayUnion", "uploadMultipleImages", "files", "length", "of", "imageFiles", "filter", "uploadObservables", "optimizeImage", "optimizedFile", "Promise", "all", "obs", "toPromise", "catch", "results", "url", "maxWidth", "__async", "resolve", "reject", "reader", "FileReader", "onload", "event", "img", "Image", "width", "height", "round", "canvas", "document", "createElement", "ctx", "getContext", "drawImage", "toBlob", "blob", "File", "name", "lastModified", "onerror", "src", "target", "result", "readAsDataURL", "updateProfileImage", "userId", "id", "set", "getCachedImageUrl", "get", "removeCachedImage", "delete", "extractPublicId", "cloudinaryUrl", "urlParts", "split", "uploadIndex", "findIndex", "part", "publicId", "slice", "join", "extensionIndex", "lastIndexOf", "factory", "\u0275fac", "providedIn"]
}
