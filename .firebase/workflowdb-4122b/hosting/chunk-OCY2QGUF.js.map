{
  "version": 3,
  "sources": ["src/app/services/task.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\nimport { \n  Firestore, \n  collection, \n  query, \n  where, \n  orderBy, \n  collectionData, \n  doc, \n  updateDoc, \n  Timestamp,\n  setDoc,\n  getDoc,\n  addDoc,\n  deleteDoc,\n  getDocs\n} from '@angular/fire/firestore';\nimport { Storage, ref, uploadString, getDownloadURL, deleteObject } from '@angular/fire/storage';\nimport { Observable, from, of } from 'rxjs';\nimport { map, catchError, tap } from 'rxjs/operators';\nimport { Reporte } from '../models/interfaces';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TaskService {\n  private firestore: Firestore = inject(Firestore);\n  private storage: Storage = inject(Storage);\n  private authService: AuthService = inject(AuthService);\n\n  constructor() { }\n\n  /**\n   * Get all pending reports assigned to a specific worker\n   * @param workerId Worker ID\n   * @returns Observable with array of pending reports\n   */\n  getPendingReportesByWorker(workerId: string): Observable<Reporte[]> {\n    if (!workerId) {\n      console.error('UserId es requerido para obtener reportes pendientes');\n      return of([]);\n    }\n    \n    console.log('Getting pending reports for worker:', workerId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    \n    // Create query without orderBy to avoid index issues\n    const reportesQuery = query(\n      reportesRef,\n      where('IdUsuario', '==', workerId),\n      where('estado', '==', 'Pendiente')\n    );\n    \n    console.log('Query params:', { workerId, estado: 'Pendiente' });\n    \n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      tap(reportes => {\n        console.log('Raw reports from Firestore:', JSON.stringify(reportes));\n      }),\n      map((reportes: any[]) => {\n        console.log('Processing reports:', reportes.length);\n        return this.processReportDates(reportes);\n      }),\n      tap(processedReports => {\n        console.log('Processed reports:', processedReports.length);\n      }),\n      catchError(error => {\n        console.error('Error getting pending reports:', error);\n        return of([]);\n      })\n    );\n  }\n\n  /**\n   * Get all completed reports for a specific worker\n   * @param workerId Worker ID\n   * @returns Observable with array of completed reports\n   */\n  getCompletedReportesByWorker(workerId: string): Observable<Reporte[]> {\n    if (!workerId) {\n      console.error('UserId es requerido para obtener reportes completados');\n      return of([]);\n    }\n    \n    console.log('Buscando reportes completados para userId:', workerId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    \n    // Query without orderBy to avoid index issues\n    const reportesQuery = query(\n      reportesRef,\n      where('IdUsuario', '==', workerId),\n      where('estado', '==', 'Completado')\n    );\n    \n    console.log('Query params for completed reports:', { workerId, estado: 'Completado' });\n    \n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      tap(reportes => {\n        console.log('Raw completed reports from Firestore:', JSON.stringify(reportes));\n      }),\n      map((reportes: any[]) => {\n        console.log('Processing completed reports:', reportes.length);\n        return this.processReportDates(reportes);\n      }),\n      tap(processedReports => {\n        console.log('Processed completed reports:', processedReports.length);\n      }),\n      catchError(error => {\n        console.error('Error getting completed reports:', error);\n        return of([]);\n      })\n    );\n  }\n\n  /**\n   * Process dates in reports to convert Firestore Timestamps to JavaScript Date objects\n   * @param reportes Array of reports\n   * @returns Processed array with correct date formats\n   */\n  private processReportDates(reportes: any[]): Reporte[] {\n    console.log('Processing dates for reports:', reportes);\n    return reportes.map(reporte => {\n      // Check if each reporte has the expected properties\n      if (!reporte) {\n        console.error('Found undefined report in array');\n        return null;\n      }\n      \n      console.log('Processing report:', reporte.IdReporte);\n      \n      // Create a new object with proper date conversions\n      const processed = {\n        ...reporte,\n        fecha: reporte.fecha ? this.convertToDate(reporte.fecha) : new Date(),\n        fechaCompletado: reporte.fechaCompletado ? this.convertToDate(reporte.fechaCompletado) : undefined,\n        fechaActualizacion: reporte.fechaActualizacion ? this.convertToDate(reporte.fechaActualizacion) : undefined,\n        fechaGeneracionPdf: reporte.fechaGeneracionPdf ? this.convertToDate(reporte.fechaGeneracionPdf) : undefined\n      };\n      \n      console.log('Processed report dates:', {\n        id: processed.IdReporte,\n        fecha: processed.fecha,\n        estado: processed.estado\n      });\n      \n      return processed;\n    }).filter(report => report !== null) as Reporte[];\n  }\n\n  /**\n   * Convert Firestore Timestamp to JavaScript Date\n   * @param date Timestamp or Date object\n   * @returns JavaScript Date object\n   */\n  private convertToDate(date: Timestamp | Date | any): Date {\n    if (!date) {\n      console.warn('Attempted to convert null/undefined date');\n      return new Date(); // Return current date as fallback\n    }\n    \n    try {\n      // If it's a Firestore Timestamp\n      if (date instanceof Timestamp || (date && typeof date.toDate === 'function')) {\n        return date.toDate();\n      }\n      \n      // If it's already a Date object\n      if (date instanceof Date) {\n        return date;\n      }\n      \n      // If it's a timestamp number (seconds or milliseconds)\n      if (typeof date === 'number') {\n        // Check if it's seconds (Firestore) or milliseconds\n        return date < 100000000000 ? new Date(date * 1000) : new Date(date);\n      }\n      \n      // If it's an object with seconds and nanoseconds (Firestore timestamp format)\n      if (date && date.seconds && typeof date.seconds === 'number') {\n        return new Date(date.seconds * 1000 + (date.nanoseconds || 0) / 1000000);\n      }\n      \n      // If it's a string, try to parse it\n      if (typeof date === 'string') {\n        return new Date(date);\n      }\n      \n      // Default fallback\n      console.warn('Unknown date format:', date);\n      return new Date();\n    } catch (error) {\n      console.error('Error converting date:', error, date);\n      return new Date(); // Return current date as fallback\n    }\n  }\n\n  /**\n   * Update report status\n   * @param reporteId Report ID\n   * @param estado New status ('Pendiente' or 'Completado')\n   * @param descripcionCompletado Optional completion description\n   * @returns Promise that resolves when the update is complete\n   */\n  async updateReporteStatus(\n    reporteId: string, \n    estado: string, \n    descripcionCompletado?: string\n  ): Promise<void> {\n    try {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n      \n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      const reporteDoc = await getDoc(reporteRef);\n      \n      if (!reporteDoc.exists()) {\n        throw new Error('El reporte no existe');\n      }\n      \n      const reporteData = reporteDoc.data();\n      const userDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      \n      if (!userDoc.exists()) {\n        throw new Error('Usuario no encontrado');\n      }\n      \n      const userData = userDoc.data();\n      const isAdmin = userData['Rol'] === 'admin';\n      const isAssignedWorker = reporteData['IdUsuario'] === currentUser.uid;\n      \n      if (!isAdmin && !isAssignedWorker) {\n        throw new Error('No tiene permisos para actualizar este reporte');\n      }\n      \n      const updateData: any = {\n        estado: estado,\n        fechaActualizacion: new Date()\n      };\n      \n      if (estado === 'Completado') {\n        updateData.fechaCompletado = new Date();\n        if (descripcionCompletado) {\n          updateData.descripcionCompletado = descripcionCompletado;\n        }\n      }\n      \n      await updateDoc(reporteRef, updateData);\n      console.log('Report status updated successfully');\n    } catch (error) {\n      console.error('Error updating report status:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store PDF for a report in Firebase Storage\n   * @param reporteId Report ID\n   * @param pdfDataUrl PDF data as data URL\n   * @returns Promise with the download URL of the stored PDF\n   */\n  async storePdfForReporte(reporteId: string, pdfDataUrl: string): Promise<string> {\n    try {\n      console.log('Storing PDF for report:', reporteId);\n      \n      // Generate the path to the PDF\n      const pdfPath = `reportes_pdf/${reporteId}.pdf`;\n      const storageRef = ref(this.storage, pdfPath);\n\n      // Extract base64 data from data URL (remove prefix)\n      const base64Data = pdfDataUrl.split(',')[1];\n      \n      // Upload PDF to Firebase Storage\n      await uploadString(storageRef, base64Data, 'base64');\n      \n      // Get the download URL\n      const downloadURL = await getDownloadURL(storageRef);\n      console.log('PDF stored successfully, URL:', downloadURL);\n      \n      // Update the report with PDF info\n      await this.updateReporteWithPdfInfo(reporteId, downloadURL);\n      \n      return downloadURL;\n    } catch (error) {\n      console.error('Error storing PDF for report:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get PDF URL for a report\n   * @param reporteId Report ID\n   * @returns Promise with the PDF URL or null if not found\n   */\n  async getPdfUrlForReporte(reporteId: string): Promise<string | null> {\n    try {\n      console.log('Getting PDF URL for report:', reporteId);\n      \n      // First, check if the URL is already stored in the report document\n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      const reporteDoc = await getDoc(reporteRef);\n      \n      if (reporteDoc.exists()) {\n        const reportData = reporteDoc.data();\n        \n        if (reportData['pdfUrl']) {\n          console.log('Found PDF URL in report document:', reportData['pdfUrl']);\n          return reportData['pdfUrl'];\n        }\n      }\n      \n      // If not, try to get the URL from Storage\n      const pdfPath = `reportes_pdf/${reporteId}.pdf`;\n      const storageRef = ref(this.storage, pdfPath);\n      const downloadURL = await getDownloadURL(storageRef);\n      \n      // Update the report with the URL for future use\n      await this.updateReporteWithPdfInfo(reporteId, downloadURL);\n      \n      return downloadURL;\n    } catch (error) {\n      console.error('PDF not found or access error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update report with PDF information\n   * @param reporteId Report ID\n   * @param pdfUrl URL of the PDF in Firebase Storage\n   * @returns Promise that resolves when the update is complete\n   */\n  async updateReporteWithPdfInfo(reporteId: string, pdfUrl: string): Promise<void> {\n    try {\n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      \n      await updateDoc(reporteRef, {\n        pdfUrl: pdfUrl,\n        reportePdfGenerado: true,\n        fechaGeneracionPdf: new Date()\n      });\n      \n      console.log('Report PDF info updated successfully with URL:', pdfUrl);\n    } catch (error) {\n      console.error('Error updating report PDF info:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete PDF from Storage\n   * @param reporteId Report ID\n   * @returns Promise that resolves when the deletion is complete\n   */\n  async deletePdfForReporte(reporteId: string): Promise<void> {\n    try {\n      const pdfPath = `reportes_pdf/${reporteId}.pdf`;\n      const storageRef = ref(this.storage, pdfPath);\n      \n      await deleteObject(storageRef);\n      console.log('PDF deleted successfully');\n    } catch (error) {\n      console.error('Error deleting PDF:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a report\n   * @param reporteId Report ID\n   * @returns Promise that resolves when the deletion is complete\n   */\n  async deleteReporte(reporteId: string): Promise<void> {\n    try {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n      \n      // Verify the user is an admin\n      const userDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      if (!userDoc.exists()) {\n        throw new Error('Usuario no encontrado');\n      }\n      \n      const userData = userDoc.data();\n      if (userData['Rol'] !== 'admin') {\n        throw new Error('Solo los administradores pueden eliminar reportes');\n      }\n      \n      // Verify the report exists\n      const reporteRef = doc(this.firestore, 'Reportes', reporteId);\n      const reporteDoc = await getDoc(reporteRef);\n      if (!reporteDoc.exists()) {\n        throw new Error('El reporte no existe');\n      }\n      \n      // Try to delete the PDF if it exists\n      try {\n        await this.deletePdfForReporte(reporteId);\n      } catch (pdfError) {\n        console.warn('No se pudo eliminar el PDF del reporte:', pdfError);\n        // Continue with deleting the report even if PDF deletion fails\n      }\n      \n      console.log('Eliminando reporte:', reporteId);\n      await deleteDoc(reporteRef);\n      console.log('Reporte eliminado exitosamente');\n    } catch (error) {\n      console.error('Error al eliminar reporte:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Assign a new report task\n   * @param reportData Report data to create\n   * @returns Promise with the new report ID\n   */\n  async assignReporte(reportData: Omit<Reporte, 'IdReporte'>): Promise<string> {\n    try {\n      console.log('Attempting to assign report with data:', JSON.stringify(reportData));\n      \n      // 1. Obtain current user and verify they're an admin\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        throw new Error('No hay usuario autenticado');\n      }\n      \n      // 2. Get current user data from Firestore\n      const adminDoc = await getDoc(doc(this.firestore, 'Usuario', currentUser.uid));\n      if (!adminDoc.exists()) {\n        throw new Error('Usuario administrador no encontrado');\n      }\n      \n      const adminData = adminDoc.data();\n      if (adminData['Rol'] !== 'admin') {\n        throw new Error('No tiene permisos para crear reportes');\n      }\n      \n      // 3. Find worker user by Username\n      const workersRef = collection(this.firestore, 'Usuario');\n      \n      console.log('Searching for worker with Username:', reportData.IdUsuario);\n      \n      const workerQuery = query(workersRef, \n        where('Username', '==', reportData.IdUsuario),\n        where('Rol', '==', 'worker')\n      );\n      \n      const workerSnapshot = await getDocs(workerQuery);\n      if (workerSnapshot.empty) {\n        console.error('Worker not found. Trying alternative search...');\n        \n        // Try alternative search without role restriction\n        const altWorkerQuery = query(workersRef, \n          where('Username', '==', reportData.IdUsuario)\n        );\n        \n        const altWorkerSnapshot = await getDocs(altWorkerQuery);\n        if (altWorkerSnapshot.empty) {\n          throw new Error('Usuario trabajador no encontrado');\n        }\n        \n        const workerDoc = altWorkerSnapshot.docs[0];\n        const workerId = workerDoc.id;\n        console.log('Found worker with different role:', workerId);\n        \n        // 4. Create report with validated data and correct worker ID\n        const reportesRef = collection(this.firestore, 'Reportes');\n        const reporteData = {\n          fecha: new Date(),\n          estado: 'Pendiente',\n          IdEmpresa: reportData.IdEmpresa,\n          IdUsuario: workerId, // Use real worker ID\n          Tipo_Trabajo: reportData.Tipo_Trabajo,\n          jobDescription: reportData.jobDescription,\n          location: reportData.location,\n          priority: reportData.priority,\n          departamento: reportData.departamento,\n          fechaActualizacion: new Date()\n        };\n        \n        // 5. Save the report\n        const docRef = await addDoc(reportesRef, reporteData);\n        \n        // 6. Update report ID\n        await updateDoc(doc(this.firestore, 'Reportes', docRef.id), {\n          IdReporte: docRef.id\n        });\n        \n        console.log('Reporte creado exitosamente:', docRef.id);\n        return docRef.id;\n      }\n      \n      const workerDoc = workerSnapshot.docs[0];\n      const workerId = workerDoc.id;\n      console.log('Found worker:', workerId);\n      \n      // 4. Create report with validated data and correct worker ID\n      const reportesRef = collection(this.firestore, 'Reportes');\n      const reporteData = {\n        fecha: new Date(),\n        estado: 'Pendiente',\n        IdEmpresa: reportData.IdEmpresa,\n        IdUsuario: workerId, // Use real worker ID\n        Tipo_Trabajo: reportData.Tipo_Trabajo,\n        jobDescription: reportData.jobDescription,\n        location: reportData.location,\n        priority: reportData.priority,\n        departamento: reportData.departamento,\n        fechaActualizacion: new Date()\n      };\n      \n      console.log('Creating report with data:', JSON.stringify(reporteData));\n      \n      // 5. Save the report\n      const docRef = await addDoc(reportesRef, reporteData);\n      \n      // 6. Update report ID\n      await updateDoc(doc(this.firestore, 'Reportes', docRef.id), {\n        IdReporte: docRef.id\n      });\n      \n      console.log('Reporte creado exitosamente:', docRef.id);\n      return docRef.id;\n    } catch (error) {\n      console.error('Error al asignar reporte:', error);\n      throw error;\n    }\n  }\n  \n  // Additional methods for getting reports by department, company, priority, etc.\n  getReportes(): Observable<Reporte[]> {\n    console.log('Obteniendo todos los reportes');\n    const reportesRef = collection(this.firestore, 'Reportes');\n    return collectionData(reportesRef, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes recuperados:', reportes);\n        return this.processReportDates(reportes);\n      })\n    );\n  }\n  \n  getReportesByDepartamento(departamento: string): Observable<Reporte[]> {\n    if (!departamento) {\n      console.error('Departamento es requerido para obtener reportes');\n      return of([]);\n    }\n    \n    console.log('Buscando reportes para departamento:', departamento);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('departamento', '==', departamento)\n    );\n    \n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados para departamento:', reportes);\n        return this.processReportDates(reportes);\n      })\n    );\n  }\n  \n  getReportesByEmpresa(empresaId: string): Observable<Reporte[]> {\n    if (!empresaId) {\n      console.error('ID de empresa es requerido para obtener reportes');\n      return of([]);\n    }\n    \n    console.log('Buscando reportes para empresa:', empresaId);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('IdEmpresa', '==', empresaId)\n    );\n    \n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados para empresa:', reportes);\n        return this.processReportDates(reportes);\n      })\n    );\n  }\n  \n  getReportesByPriority(priority: string): Observable<Reporte[]> {\n    if (!priority) {\n      console.error('Prioridad es requerida para obtener reportes');\n      return of([]);\n    }\n    \n    console.log('Buscando reportes por prioridad:', priority);\n    const reportesRef = collection(this.firestore, 'Reportes');\n    const reportesQuery = query(\n      reportesRef,\n      where('priority', '==', priority)\n    );\n    \n    return collectionData(reportesQuery, { idField: 'IdReporte' }).pipe(\n      map((reportes: any[]) => {\n        console.log('Reportes encontrados por prioridad:', reportes);\n        return this.processReportDates(reportes);\n      })\n    );\n  }\n  \n  async getFilteredReportes(): Promise<Observable<Reporte[]>> {\n    try {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        console.error('No hay usuario autenticado');\n        return of([]);\n      }\n      \n      // Get current user data\n      const userData = await this.authService.getUserData(currentUser.uid);\n      if (!userData) {\n        console.error('Datos de usuario no encontrados');\n        return of([]);\n      }\n      \n      // If admin level 3, filter reports only by users created by them\n      if (userData.Rol === 'admin' && userData.NivelAdmin === '3') {\n        return this.getReportesByCreator(currentUser.uid);\n      }\n      \n      // For other cases, return all reports\n      return this.getReportes();\n    } catch (error) {\n      console.error('Error al filtrar reportes:', error);\n      return of([]);\n    }\n  }\n  \n  getReportesByCreator(creatorId: string): Observable<Reporte[]> {\n    return new Observable<Reporte[]>(observer => {\n      // First get users created by this admin\n      this.authService.getUsersByCreator(creatorId).then(users => {\n        // Extract only user IDs\n        const userIds = users.map(user => user.IdUsuario);\n        \n        if (userIds.length === 0) {\n          observer.next([]);\n          observer.complete();\n          return;\n        }\n        \n        // Get reports for these users\n        const reportesRef = collection(this.firestore, 'Reportes');\n        \n        // Firebase doesn't allow 'in' queries with more than 10 elements\n        // Split into groups of 10 if needed\n        const userIdChunks = this.chunkArray(userIds, 10);\n        const reportePromises: Promise<Reporte[]>[] = [];\n        \n        userIdChunks.forEach(chunk => {\n          const q = query(reportesRef, where('IdUsuario', 'in', chunk));\n          const promise = getDocs(q).then(snapshot => {\n            const reportes: any[] = [];\n            snapshot.forEach(doc => {\n              reportes.push({\n                IdReporte: doc.id,\n                ...doc.data()\n              });\n            });\n            return this.processReportDates(reportes);\n          });\n          reportePromises.push(promise);\n        });\n        \n        Promise.all(reportePromises).then(reportesArrays => {\n          // Combine all report arrays\n          const allReportes = reportesArrays.flat();\n          observer.next(allReportes);\n          observer.complete();\n        }).catch(error => {\n          console.error('Error obteniendo reportes:', error);\n          observer.error(error);\n        });\n      }).catch(error => {\n        console.error('Error obteniendo usuarios:', error);\n        observer.error(error);\n      });\n    });\n  }\n  \n  // Helper method to split arrays into groups of specific size\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n}"],
  "mappings": "yWA0BA,IAAaA,IAAW,IAAA,CAAlB,MAAOA,CAAW,CACdC,UAAuBC,EAAOC,CAAS,EACvCC,QAAmBF,EAAOG,CAAO,EACjCC,YAA2BJ,EAAOK,CAAW,EAErDC,aAAA,CAAgB,CAOhBC,2BAA2BC,EAAgB,CACzC,GAAI,CAACA,EACHC,eAAQC,MAAM,sDAAsD,EAC7DC,EAAG,CAAA,CAAE,EAGdF,QAAQG,IAAI,sCAAuCJ,CAAQ,EAC3D,IAAMK,EAAcC,EAAW,KAAKf,UAAW,UAAU,EAGnDgB,EAAgBC,EACpBH,EACAI,EAAM,YAAa,KAAMT,CAAQ,EACjCS,EAAM,SAAU,KAAM,WAAW,CAAC,EAGpCR,eAAQG,IAAI,gBAAiB,CAAEJ,SAAAA,EAAUU,OAAQ,WAAW,CAAE,EAEvDC,EAAeJ,EAAe,CAAEK,QAAS,WAAW,CAAE,EAAEC,KAC7DC,EAAIC,GAAW,CACbd,QAAQG,IAAI,8BAA+BY,KAAKC,UAAUF,CAAQ,CAAC,CACrE,CAAC,EACDG,EAAKH,IACHd,QAAQG,IAAI,sBAAuBW,EAASI,MAAM,EAC3C,KAAKC,mBAAmBL,CAAQ,EACxC,EACDD,EAAIO,GAAmB,CACrBpB,QAAQG,IAAI,qBAAsBiB,EAAiBF,MAAM,CAC3D,CAAC,EACDG,EAAWpB,IACTD,QAAQC,MAAM,iCAAkCA,CAAK,EAC9CC,EAAG,CAAA,CAAE,EACb,CAAC,CAEN,CAOAoB,6BAA6BvB,EAAgB,CAC3C,GAAI,CAACA,EACHC,eAAQC,MAAM,uDAAuD,EAC9DC,EAAG,CAAA,CAAE,EAGdF,QAAQG,IAAI,6CAA8CJ,CAAQ,EAClE,IAAMK,EAAcC,EAAW,KAAKf,UAAW,UAAU,EAGnDgB,EAAgBC,EACpBH,EACAI,EAAM,YAAa,KAAMT,CAAQ,EACjCS,EAAM,SAAU,KAAM,YAAY,CAAC,EAGrCR,eAAQG,IAAI,sCAAuC,CAAEJ,SAAAA,EAAUU,OAAQ,YAAY,CAAE,EAE9EC,EAAeJ,EAAe,CAAEK,QAAS,WAAW,CAAE,EAAEC,KAC7DC,EAAIC,GAAW,CACbd,QAAQG,IAAI,wCAAyCY,KAAKC,UAAUF,CAAQ,CAAC,CAC/E,CAAC,EACDG,EAAKH,IACHd,QAAQG,IAAI,gCAAiCW,EAASI,MAAM,EACrD,KAAKC,mBAAmBL,CAAQ,EACxC,EACDD,EAAIO,GAAmB,CACrBpB,QAAQG,IAAI,+BAAgCiB,EAAiBF,MAAM,CACrE,CAAC,EACDG,EAAWpB,IACTD,QAAQC,MAAM,mCAAoCA,CAAK,EAChDC,EAAG,CAAA,CAAE,EACb,CAAC,CAEN,CAOQiB,mBAAmBL,EAAe,CACxCd,eAAQG,IAAI,gCAAiCW,CAAQ,EAC9CA,EAASG,IAAIM,GAAU,CAE5B,GAAI,CAACA,EACHvB,eAAQC,MAAM,iCAAiC,EACxC,KAGTD,QAAQG,IAAI,qBAAsBoB,EAAQC,SAAS,EAGnD,IAAMC,EAAYC,EAAAC,EAAA,GACbJ,GADa,CAEhBK,MAAOL,EAAQK,MAAQ,KAAKC,cAAcN,EAAQK,KAAK,EAAI,IAAIE,KAC/DC,gBAAiBR,EAAQQ,gBAAkB,KAAKF,cAAcN,EAAQQ,eAAe,EAAIC,OACzFC,mBAAoBV,EAAQU,mBAAqB,KAAKJ,cAAcN,EAAQU,kBAAkB,EAAID,OAClGE,mBAAoBX,EAAQW,mBAAqB,KAAKL,cAAcN,EAAQW,kBAAkB,EAAIF,SAGpGhC,eAAQG,IAAI,0BAA2B,CACrCgC,GAAIV,EAAUD,UACdI,MAAOH,EAAUG,MACjBnB,OAAQgB,EAAUhB,OACnB,EAEMgB,CACT,CAAC,EAAEW,OAAOC,GAAUA,IAAW,IAAI,CACrC,CAOQR,cAAcS,EAA4B,CAChD,GAAI,CAACA,EACHtC,eAAQuC,KAAK,0CAA0C,EAChD,IAAIT,KAGb,GAAI,CAEF,OAAIQ,aAAgBE,GAAcF,GAAQ,OAAOA,EAAKG,QAAW,WACxDH,EAAKG,OAAM,EAIhBH,aAAgBR,KACXQ,EAIL,OAAOA,GAAS,SAEXA,EAAO,KAAe,IAAIR,KAAKQ,EAAO,GAAI,EAAI,IAAIR,KAAKQ,CAAI,EAIhEA,GAAQA,EAAKI,SAAW,OAAOJ,EAAKI,SAAY,SAC3C,IAAIZ,KAAKQ,EAAKI,QAAU,KAAQJ,EAAKK,aAAe,GAAK,GAAO,EAIrE,OAAOL,GAAS,SACX,IAAIR,KAAKQ,CAAI,GAItBtC,QAAQuC,KAAK,uBAAwBD,CAAI,EAClC,IAAIR,KACb,OAAS7B,EAAO,CACdD,eAAQC,MAAM,yBAA0BA,EAAOqC,CAAI,EAC5C,IAAIR,IACb,CACF,CASMc,oBACJC,EACApC,EACAqC,EAA8B,QAAAC,EAAA,sBAE9B,GAAI,CACF,IAAMC,EAAc,MAAM,KAAKrD,YAAYsD,eAAc,EACzD,GAAI,CAACD,EACH,MAAM,IAAIE,MAAM,4BAA4B,EAG9C,IAAMC,EAAaC,EAAI,KAAK9D,UAAW,WAAYuD,CAAS,EACtDQ,EAAa,MAAMC,EAAOH,CAAU,EAE1C,GAAI,CAACE,EAAWE,OAAM,EACpB,MAAM,IAAIL,MAAM,sBAAsB,EAGxC,IAAMM,EAAcH,EAAWI,KAAI,EAC7BC,EAAU,MAAMJ,EAAOF,EAAI,KAAK9D,UAAW,UAAW0D,EAAYW,GAAG,CAAC,EAE5E,GAAI,CAACD,EAAQH,OAAM,EACjB,MAAM,IAAIL,MAAM,uBAAuB,EAIzC,IAAMU,EADWF,EAAQD,KAAI,EACJ,MAAW,QAC9BI,EAAmBL,EAAY,YAAiBR,EAAYW,IAElE,GAAI,CAACC,GAAW,CAACC,EACf,MAAM,IAAIX,MAAM,gDAAgD,EAGlE,IAAMY,EAAkB,CACtBrD,OAAQA,EACRwB,mBAAoB,IAAIH,MAGtBrB,IAAW,eACbqD,EAAW/B,gBAAkB,IAAID,KAC7BgB,IACFgB,EAAWhB,sBAAwBA,IAIvC,MAAMiB,EAAUZ,EAAYW,CAAU,EACtC9D,QAAQG,IAAI,oCAAoC,CAClD,OAASF,EAAO,CACdD,cAAQC,MAAM,gCAAiCA,CAAK,EAC9CA,CACR,CACF,GAQM+D,mBAAmBnB,EAAmBoB,EAAkB,QAAAlB,EAAA,sBAC5D,GAAI,CACF/C,QAAQG,IAAI,0BAA2B0C,CAAS,EAGhD,IAAMqB,EAAU,gBAAgBrB,CAAS,OACnCsB,EAAaC,EAAI,KAAK3E,QAASyE,CAAO,EAGtCG,EAAaJ,EAAWK,MAAM,GAAG,EAAE,CAAC,EAG1C,MAAMC,EAAaJ,EAAYE,EAAY,QAAQ,EAGnD,IAAMG,EAAc,MAAMC,EAAeN,CAAU,EACnDnE,eAAQG,IAAI,gCAAiCqE,CAAW,EAGxD,MAAM,KAAKE,yBAAyB7B,EAAW2B,CAAW,EAEnDA,CACT,OAASvE,EAAO,CACdD,cAAQC,MAAM,gCAAiCA,CAAK,EAC9CA,CACR,CACF,GAOM0E,oBAAoB9B,EAAiB,QAAAE,EAAA,sBACzC,GAAI,CACF/C,QAAQG,IAAI,8BAA+B0C,CAAS,EAGpD,IAAMM,EAAaC,EAAI,KAAK9D,UAAW,WAAYuD,CAAS,EACtDQ,EAAa,MAAMC,EAAOH,CAAU,EAE1C,GAAIE,EAAWE,OAAM,EAAI,CACvB,IAAMqB,EAAavB,EAAWI,KAAI,EAElC,GAAImB,EAAW,OACb5E,eAAQG,IAAI,oCAAqCyE,EAAW,MAAS,EAC9DA,EAAW,MAEtB,CAGA,IAAMV,EAAU,gBAAgBrB,CAAS,OACnCsB,EAAaC,EAAI,KAAK3E,QAASyE,CAAO,EACtCM,EAAc,MAAMC,EAAeN,CAAU,EAGnD,aAAM,KAAKO,yBAAyB7B,EAAW2B,CAAW,EAEnDA,CACT,OAASvE,EAAO,CACdD,eAAQC,MAAM,iCAAkCA,CAAK,EAC9C,IACT,CACF,GAQMyE,yBAAyB7B,EAAmBgC,EAAc,QAAA9B,EAAA,sBAC9D,GAAI,CACF,IAAMI,EAAaC,EAAI,KAAK9D,UAAW,WAAYuD,CAAS,EAE5D,MAAMkB,EAAUZ,EAAY,CAC1B0B,OAAQA,EACRC,mBAAoB,GACpB5C,mBAAoB,IAAIJ,KACzB,EAED9B,QAAQG,IAAI,iDAAkD0E,CAAM,CACtE,OAAS5E,EAAO,CACdD,cAAQC,MAAM,kCAAmCA,CAAK,EAChDA,CACR,CACF,GAOM8E,oBAAoBlC,EAAiB,QAAAE,EAAA,sBACzC,GAAI,CACF,IAAMmB,EAAU,gBAAgBrB,CAAS,OACnCsB,EAAaC,EAAI,KAAK3E,QAASyE,CAAO,EAE5C,MAAMc,EAAab,CAAU,EAC7BnE,QAAQG,IAAI,0BAA0B,CACxC,OAASF,EAAO,CACdD,cAAQC,MAAM,sBAAuBA,CAAK,EACpCA,CACR,CACF,GAOMgF,cAAcpC,EAAiB,QAAAE,EAAA,sBACnC,GAAI,CACF,IAAMC,EAAc,MAAM,KAAKrD,YAAYsD,eAAc,EACzD,GAAI,CAACD,EACH,MAAM,IAAIE,MAAM,4BAA4B,EAI9C,IAAMQ,EAAU,MAAMJ,EAAOF,EAAI,KAAK9D,UAAW,UAAW0D,EAAYW,GAAG,CAAC,EAC5E,GAAI,CAACD,EAAQH,OAAM,EACjB,MAAM,IAAIL,MAAM,uBAAuB,EAIzC,GADiBQ,EAAQD,KAAI,EAChB,MAAW,QACtB,MAAM,IAAIP,MAAM,mDAAmD,EAIrE,IAAMC,EAAaC,EAAI,KAAK9D,UAAW,WAAYuD,CAAS,EAE5D,GAAI,EADe,MAAMS,EAAOH,CAAU,GAC1BI,OAAM,EACpB,MAAM,IAAIL,MAAM,sBAAsB,EAIxC,GAAI,CACF,MAAM,KAAK6B,oBAAoBlC,CAAS,CAC1C,OAASqC,EAAU,CACjBlF,QAAQuC,KAAK,0CAA2C2C,CAAQ,CAElE,CAEAlF,QAAQG,IAAI,sBAAuB0C,CAAS,EAC5C,MAAMsC,EAAUhC,CAAU,EAC1BnD,QAAQG,IAAI,gCAAgC,CAC9C,OAASF,EAAO,CACdD,cAAQC,MAAM,6BAA8BA,CAAK,EAC3CA,CACR,CACF,GAOMmF,cAAcR,EAAsC,QAAA7B,EAAA,sBACxD,GAAI,CACF/C,QAAQG,IAAI,yCAA0CY,KAAKC,UAAU4D,CAAU,CAAC,EAGhF,IAAM5B,EAAc,MAAM,KAAKrD,YAAYsD,eAAc,EACzD,GAAI,CAACD,EACH,MAAM,IAAIE,MAAM,4BAA4B,EAI9C,IAAMmC,EAAW,MAAM/B,EAAOF,EAAI,KAAK9D,UAAW,UAAW0D,EAAYW,GAAG,CAAC,EAC7E,GAAI,CAAC0B,EAAS9B,OAAM,EAClB,MAAM,IAAIL,MAAM,qCAAqC,EAIvD,GADkBmC,EAAS5B,KAAI,EACjB,MAAW,QACvB,MAAM,IAAIP,MAAM,uCAAuC,EAIzD,IAAMoC,EAAajF,EAAW,KAAKf,UAAW,SAAS,EAEvDU,QAAQG,IAAI,sCAAuCyE,EAAWW,SAAS,EAEvE,IAAMC,EAAcjF,EAAM+E,EACxB9E,EAAM,WAAY,KAAMoE,EAAWW,SAAS,EAC5C/E,EAAM,MAAO,KAAM,QAAQ,CAAC,EAGxBiF,EAAiB,MAAMC,EAAQF,CAAW,EAChD,GAAIC,EAAeE,MAAO,CACxB3F,QAAQC,MAAM,gDAAgD,EAG9D,IAAM2F,EAAiBrF,EAAM+E,EAC3B9E,EAAM,WAAY,KAAMoE,EAAWW,SAAS,CAAC,EAGzCM,EAAoB,MAAMH,EAAQE,CAAc,EACtD,GAAIC,EAAkBF,MACpB,MAAM,IAAIzC,MAAM,kCAAkC,EAIpD,IAAMnD,EADY8F,EAAkBC,KAAK,CAAC,EACf3D,GAC3BnC,QAAQG,IAAI,oCAAqCJ,CAAQ,EAGzD,IAAMK,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACnDkE,EAAc,CAClB5B,MAAO,IAAIE,KACXrB,OAAQ,YACRsF,UAAWnB,EAAWmB,UACtBR,UAAWxF,EACXiG,aAAcpB,EAAWoB,aACzBC,eAAgBrB,EAAWqB,eAC3BC,SAAUtB,EAAWsB,SACrBC,SAAUvB,EAAWuB,SACrBC,aAAcxB,EAAWwB,aACzBnE,mBAAoB,IAAIH,MAIpBuE,EAAS,MAAMC,EAAOlG,EAAaoD,CAAW,EAGpD,aAAMO,EAAUX,EAAI,KAAK9D,UAAW,WAAY+G,EAAOlE,EAAE,EAAG,CAC1DX,UAAW6E,EAAOlE,GACnB,EAEDnC,QAAQG,IAAI,+BAAgCkG,EAAOlE,EAAE,EAC9CkE,EAAOlE,EAChB,CAGA,IAAMpC,EADY0F,EAAeK,KAAK,CAAC,EACZ3D,GAC3BnC,QAAQG,IAAI,gBAAiBJ,CAAQ,EAGrC,IAAMK,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACnDkE,EAAc,CAClB5B,MAAO,IAAIE,KACXrB,OAAQ,YACRsF,UAAWnB,EAAWmB,UACtBR,UAAWxF,EACXiG,aAAcpB,EAAWoB,aACzBC,eAAgBrB,EAAWqB,eAC3BC,SAAUtB,EAAWsB,SACrBC,SAAUvB,EAAWuB,SACrBC,aAAcxB,EAAWwB,aACzBnE,mBAAoB,IAAIH,MAG1B9B,QAAQG,IAAI,6BAA8BY,KAAKC,UAAUwC,CAAW,CAAC,EAGrE,IAAM6C,EAAS,MAAMC,EAAOlG,EAAaoD,CAAW,EAGpD,aAAMO,EAAUX,EAAI,KAAK9D,UAAW,WAAY+G,EAAOlE,EAAE,EAAG,CAC1DX,UAAW6E,EAAOlE,GACnB,EAEDnC,QAAQG,IAAI,+BAAgCkG,EAAOlE,EAAE,EAC9CkE,EAAOlE,EAChB,OAASlC,EAAO,CACdD,cAAQC,MAAM,4BAA6BA,CAAK,EAC1CA,CACR,CACF,GAGAsG,aAAW,CACTvG,QAAQG,IAAI,+BAA+B,EAC3C,IAAMC,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACzD,OAAOoB,EAAeN,EAAa,CAAEO,QAAS,WAAW,CAAE,EAAEC,KAC3DK,EAAKH,IACHd,QAAQG,IAAI,wBAAyBW,CAAQ,EACtC,KAAKK,mBAAmBL,CAAQ,EACxC,CAAC,CAEN,CAEA0F,0BAA0BJ,EAAoB,CAC5C,GAAI,CAACA,EACHpG,eAAQC,MAAM,iDAAiD,EACxDC,EAAG,CAAA,CAAE,EAGdF,QAAQG,IAAI,uCAAwCiG,CAAY,EAChE,IAAMhG,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACnDgB,EAAgBC,EACpBH,EACAI,EAAM,eAAgB,KAAM4F,CAAY,CAAC,EAG3C,OAAO1F,EAAeJ,EAAe,CAAEK,QAAS,WAAW,CAAE,EAAEC,KAC7DK,EAAKH,IACHd,QAAQG,IAAI,0CAA2CW,CAAQ,EACxD,KAAKK,mBAAmBL,CAAQ,EACxC,CAAC,CAEN,CAEA2F,qBAAqBC,EAAiB,CACpC,GAAI,CAACA,EACH1G,eAAQC,MAAM,kDAAkD,EACzDC,EAAG,CAAA,CAAE,EAGdF,QAAQG,IAAI,kCAAmCuG,CAAS,EACxD,IAAMtG,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACnDgB,EAAgBC,EACpBH,EACAI,EAAM,YAAa,KAAMkG,CAAS,CAAC,EAGrC,OAAOhG,EAAeJ,EAAe,CAAEK,QAAS,WAAW,CAAE,EAAEC,KAC7DK,EAAKH,IACHd,QAAQG,IAAI,qCAAsCW,CAAQ,EACnD,KAAKK,mBAAmBL,CAAQ,EACxC,CAAC,CAEN,CAEA6F,sBAAsBR,EAAgB,CACpC,GAAI,CAACA,EACHnG,eAAQC,MAAM,8CAA8C,EACrDC,EAAG,CAAA,CAAE,EAGdF,QAAQG,IAAI,mCAAoCgG,CAAQ,EACxD,IAAM/F,EAAcC,EAAW,KAAKf,UAAW,UAAU,EACnDgB,EAAgBC,EACpBH,EACAI,EAAM,WAAY,KAAM2F,CAAQ,CAAC,EAGnC,OAAOzF,EAAeJ,EAAe,CAAEK,QAAS,WAAW,CAAE,EAAEC,KAC7DK,EAAKH,IACHd,QAAQG,IAAI,sCAAuCW,CAAQ,EACpD,KAAKK,mBAAmBL,CAAQ,EACxC,CAAC,CAEN,CAEM8F,qBAAmB,QAAA7D,EAAA,sBACvB,GAAI,CACF,IAAMC,EAAc,MAAM,KAAKrD,YAAYsD,eAAc,EACzD,GAAI,CAACD,EACHhD,eAAQC,MAAM,4BAA4B,EACnCC,EAAG,CAAA,CAAE,EAId,IAAM2G,EAAW,MAAM,KAAKlH,YAAYmH,YAAY9D,EAAYW,GAAG,EACnE,OAAKkD,EAMDA,EAASE,MAAQ,SAAWF,EAASG,aAAe,IAC/C,KAAKC,qBAAqBjE,EAAYW,GAAG,EAI3C,KAAK4C,YAAW,GAVrBvG,QAAQC,MAAM,iCAAiC,EACxCC,EAAG,CAAA,CAAE,EAUhB,OAASD,EAAO,CACdD,eAAQC,MAAM,6BAA8BA,CAAK,EAC1CC,EAAG,CAAA,CAAE,CACd,CACF,GAEA+G,qBAAqBC,EAAiB,CACpC,OAAO,IAAIC,EAAsBC,GAAW,CAE1C,KAAKzH,YAAY0H,kBAAkBH,CAAS,EAAEI,KAAKC,GAAQ,CAEzD,IAAMC,EAAUD,EAAMtG,IAAIwG,GAAQA,EAAKlC,SAAS,EAEhD,GAAIiC,EAAQtG,SAAW,EAAG,CACxBkG,EAASM,KAAK,CAAA,CAAE,EAChBN,EAASO,SAAQ,EACjB,MACF,CAGA,IAAMvH,EAAcC,EAAW,KAAKf,UAAW,UAAU,EAInDsI,EAAe,KAAKC,WAAWL,EAAS,EAAE,EAC1CM,EAAwC,CAAA,EAE9CF,EAAaG,QAAQC,GAAQ,CAC3B,IAAMC,EAAI1H,EAAMH,EAAaI,EAAM,YAAa,KAAMwH,CAAK,CAAC,EACtDE,EAAUxC,EAAQuC,CAAC,EAAEX,KAAKa,GAAW,CACzC,IAAMrH,EAAkB,CAAA,EACxBqH,OAAAA,EAASJ,QAAQ3E,GAAM,CACrBtC,EAASsH,KAAKzG,EAAA,CACZH,UAAW4B,EAAIjB,IACZiB,EAAIK,KAAI,EACZ,CACH,CAAC,EACM,KAAKtC,mBAAmBL,CAAQ,CACzC,CAAC,EACDgH,EAAgBM,KAAKF,CAAO,CAC9B,CAAC,EAEDG,QAAQC,IAAIR,CAAe,EAAER,KAAKiB,GAAiB,CAEjD,IAAMC,EAAcD,EAAeE,KAAI,EACvCrB,EAASM,KAAKc,CAAW,EACzBpB,EAASO,SAAQ,CACnB,CAAC,EAAEe,MAAMzI,GAAQ,CACfD,QAAQC,MAAM,6BAA8BA,CAAK,EACjDmH,EAASnH,MAAMA,CAAK,CACtB,CAAC,CACH,CAAC,EAAEyI,MAAMzI,GAAQ,CACfD,QAAQC,MAAM,6BAA8BA,CAAK,EACjDmH,EAASnH,MAAMA,CAAK,CACtB,CAAC,CACH,CAAC,CACH,CAGQ4H,WAAcc,EAAYC,EAAiB,CACjD,IAAMC,EAAgB,CAAA,EACtB,QAASC,EAAI,EAAGA,EAAIH,EAAMzH,OAAQ4H,GAAKF,EACrCC,EAAOT,KAAKO,EAAMI,MAAMD,EAAGA,EAAIF,CAAS,CAAC,EAE3C,OAAOC,CACT,4CA9pBWxJ,EAAW,6BAAXA,EAAW2J,QAAX3J,EAAW4J,UAAAC,WAFV,MAAM,CAAA,SAEP7J,CAAW,GAAA",
  "names": ["TaskService", "firestore", "inject", "Firestore", "storage", "Storage", "authService", "AuthService", "constructor", "getPendingReportesByWorker", "workerId", "console", "error", "of", "log", "reportesRef", "collection", "reportesQuery", "query", "where", "estado", "collectionData", "idField", "pipe", "tap", "reportes", "JSON", "stringify", "map", "length", "processReportDates", "processedReports", "catchError", "getCompletedReportesByWorker", "reporte", "IdReporte", "processed", "__spreadProps", "__spreadValues", "fecha", "convertToDate", "Date", "fechaCompletado", "undefined", "fechaActualizacion", "fechaGeneracionPdf", "id", "filter", "report", "date", "warn", "Timestamp", "toDate", "seconds", "nanoseconds", "updateReporteStatus", "reporteId", "descripcionCompletado", "__async", "currentUser", "getCurrentUser", "Error", "reporteRef", "doc", "reporteDoc", "getDoc", "exists", "reporteData", "data", "userDoc", "uid", "isAdmin", "isAssignedWorker", "updateData", "updateDoc", "storePdfForReporte", "pdfDataUrl", "pdfPath", "storageRef", "ref", "base64Data", "split", "uploadString", "downloadURL", "getDownloadURL", "updateReporteWithPdfInfo", "getPdfUrlForReporte", "reportData", "pdfUrl", "reportePdfGenerado", "deletePdfForReporte", "deleteObject", "deleteReporte", "pdfError", "deleteDoc", "assignReporte", "adminDoc", "workersRef", "IdUsuario", "workerQuery", "workerSnapshot", "getDocs", "empty", "altWorkerQuery", "altWorkerSnapshot", "docs", "IdEmpresa", "Tipo_Trabajo", "jobDescription", "location", "priority", "departamento", "docRef", "addDoc", "getReportes", "getReportesByDepartamento", "getReportesByEmpresa", "empresaId", "getReportesByPriority", "getFilteredReportes", "userData", "getUserData", "Rol", "NivelAdmin", "getReportesByCreator", "creatorId", "Observable", "observer", "getUsersByCreator", "then", "users", "userIds", "user", "next", "complete", "userIdChunks", "chunkArray", "reportePromises", "forEach", "chunk", "q", "promise", "snapshot", "push", "Promise", "all", "reportesArrays", "allReportes", "flat", "catch", "array", "chunkSize", "chunks", "i", "slice", "factory", "\u0275fac", "providedIn"]
}
